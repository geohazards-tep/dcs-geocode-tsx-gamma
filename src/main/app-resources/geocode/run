#! /bin/bash

# source the ciop functions (e.g. ciop-log)
source ${ciop_job_include}
set -x
# define the exit codes
SUCCESS=0
ERR_PAR=2
ERR_MOSAIC=3
ERR_MULTILOOK=4

# create a TMPDIR in /tmp to use GAMMA
UUIDTMP="/tmp/`uuidgen`"
mkdir -p ${UUIDTMP}
export TMPDIR=${UUIDTMP}
chmod 777 ${UUIDTMP}

export PATH=/opt/gamma/DIFF/bin:/opt/gamma/DISP/bin/:/opt/gamma/ISP/bin:/opt/gamma/LAT/bin:$PATH

# add a trap to exit gracefully
function cleanExit ()
{
  local retval=$?
  local msg=""
  case "$retval" in
    $SUCCESS) msg="Processing successfully concluded";;
    $ERR_PAR) msg="Failed to ingest the Sentinel-1 product with GAMMA";;
    $ERR_MOSAIC) msg="Failed to create the S1 SLC mosaic";;
    $ERR_MULTILOOK) msg="Failed to multi look";;
  *) msg="Unknown error";;
  esac

  [ "$retval" != "0" ] && ciop-log "ERROR" "Error $retval - $msg, processing aborted" || ciop-log "INFO" "$msg"
  exit $retval
}

trap cleanExit EXIT

function ingest() {
 
 local input=$1
 local xpath="//level1Product/productComponents/imageData/polLayer/text()"
  
 local leader="$( tar tfz ${input} | grep "\.xml$" | sed 's#.*/\(.*\)#\1#g' | grep "^T.*\.xml" )"
 local leader_path="$( tar tfz ${input} | grep ${leader} )"

 # extract leader file
 tar -xzOf ${input} ${leader_path} > ${TMPDIR}/${leader}

 # export the polarization list
 export POLARIZATION="$( xmllint -xpath ${xpath} ${leader} | sed -r 's/(.{2})/\1 /g' )"
 
 for polarization in ${POLARIZATION}
 do
   xpath="//level1Product/productComponents/imageData[polLayer/text()=\"${polarization}\"]/file/location/filename/text()"
   cos=$( dirname ${leader})/$( xmllint -xpath ${xpath} ${leader} )
  
   cos_path="$( tar tfz ${input} | grep ${cos} )" 
   # extract the cos .file
   tar -xzOf ${input} ${cos_path} > ${TMPDIR}/${cos}

   par_TX_SLC \
    ${leader} \
    ${cos} \
    ${TMPDIR}/${polarization}.slc.par \
    ${TMPDIR}/${polarization}.slc \
    ${polarization} &> ${TMPDIR}/par_TX_SLC_${polarization}.log || return 4 
  done

}

function mlook() {
  
  for polarization in ${POLARIZATION}
  do
    multi_look \
      ${TMPDIR}/${polarization}.slc \
      ${TMPDIR}/${polarization}.slc.par \
      ${TMPDIR}/${polarization}.mli \
      ${TMPDIR}/${polarization}.mli.par 6 4 &> ${TMPDIR}/multi_look_${polarization}.log || return 6
  done
}

function radcm() {

  for polarization in ${POLARIZATION}
  do
    radcal_MLI \
      ${TMPDIR}/${polarization}.mli \
      ${TMPDIR}/${polarization}.slc.par - \
      ${TMPDIR}/${polarization}.cmli - 0 0 1 0.0 - &> ${TMPDIR}/radcal_MLI_${polarization}.lop || return 8
  done
}

function geocodeb() {

  local r_samples=$1
  local w=$2

  for polarization in ${POLARIZATION}
  do
    geocode_back \
      ${TMPDIR}/${polarization}.cmli \
      ${r_samples} \
      ${TMPDIR}/DEM.lookup_table \
      ${TMPDIR}/${polarization}.cmli.geocoded ${w} - 0 0 &> ${TMPDIR}/geocode_back_${polarization}.log || return 10
   done

}

function ras() {

  local r_samples=$1

  for polarization in ${POLARIZATION}
  do
    raspwr \
      ${TMPDIR}/${polarization}.cmli \
      ${range_samples} \
      1 0 1 1 - - - \
      ${TMPDIR}/${polarization}.cmli.ras &> ${TMPDIR}/raspwr_${polarization}.log
  done
}

function main () {

  cd ${TMPDIR}

  while read input
  do
    [[ ${input} == *"response.xml"* ]] && continue 
   
    enclosure="$( opensearch-client ${input} enclosure )"
    local_input="$( ciop-copy -z -o $TMPDIR ${enclosure} )"

  
    ingest \
      ${local_input} || return $?

    mlook || return $? 

    radcm || return $?

    read -a pol_array <<<$POLARIZATION
    gec_map \
      ${TMPDIR}/${pol_array[0]}.mli.par - \
      ${DEM_PAR} 0.0 \
      $( dirname ${DEM_PAR} )/DEM.dem_seg.par \
      ${TMPDIR}/DEM.lookup_table 20 20 &> ${TMPDIR}/gec_map.log || return $?

      width=$( cat $output/DEM.dem_seg.par | grep width | tr  -s " " | cut -d " " -f 2 )
      range_samples=$( cat $output/${pol_array[0]}.mli.par | grep range_samples | tr  -s " " | cut -d " " -f 2 )

      geocodeb ${range_samples} ${width} || return $?

    [ ${#pol_array[@]} == 2 ] && {   
      ratio \
        ${TMPDIR}/${pol_array[0]}.cmli \
        ${TMPDIR}/${pol_array[1]}.cmli \
        ${TMPDIR}/${pol_array[0]}${pol_array[1]} \
        ${range_samples} &> ${TMPDIR}/ratio.log || return $?
    }

    ras

    [ ${#pol_array[@]} == 2 ] && {
      # dual polarization, process an RGB image
      raspwr \
        ${TMPDIR}/${pol_array[0]}${pol_array[1]} \
        ${range_samples} \
        1 0 1 1 - - - \
        ${TMPDIR}/${pol_array[0]}${pol_array[1]}.cmli.ras &> ${TMPDIR}/raspwr_${pol_array[0]}${pol_array[1]}.log || return $?

      ras_to_rgb \
        ${TMPDIR}/${pol_array[0]}.cmli.ras \
        ${TMPDIR}/${pol_array[1]}.cmli.ras \
        ${TMPDIR}/${pol_array[0]}${pol_array[1]}.cmli.ras \
        ${TMPDIR}/RGB.bmp &> ${TMPDIR}/ras_to_rgb.log || return $? 

      geocode_back \
        ${TMPDIR}/RGB.bmp \
        ${range_samples} \
        ${TMPDIR}/DEM.lookup_table \
        ${TMPDIR}/RGB.geocoded.bmp \
        ${width} - 0 2 &> ${TMPDIR}/geocode_back_RGB.log || return $?
    } || {
      # it's a single polarization product, process it as single band image
      ras_ras \
        ${TMPDIR}/${pol_array[0]}.cmli.ras \
        ${TMPDIR}/GRAY.bmp &> ${TMPDIR}/ras_to_ras.log || return $?
      
      geocode_back \
        ${TMPDIR}/GRAY.bmp \
        ${range_samples} \
        ${TMPDIR}/DEM.lookup_table \
        ${TMPDIR}/GRAY.geo.bmp \
        ${width} - 0 2 &> ${TMPDIR}/geocode_back_GRAY.log || return $? - 0 2
     
    }
  done
}

# retrieve the DEM
mkdir -p ${TMPDIR}/workdir/dem
wps_result="$( ciop-browseresults -r ${CIOP_WF_RUN_ID} -j node_dem -w | tr -d '\r' | tr '\n' ';' | cut -d ";" -f 1)"
# extract the result URL
curl -L -o ${TMPDIR}/workdir/dem/dem.tgz "${wps_result}" 2> /dev/null
tar xzf ${TMPDIR}/workdir/dem/dem.tgz -C ${TMPDIR}/workdir/dem/

export DEM="$( find $TMPDIR/workdir/dem -name "*.dem" )"
export DEM_PAR="$( find $TMPDIR/workdir/dem -name "*.dem.par" )"

chmod -R 777 ${TMPDIR}/workdir

cat | main || exit $?
